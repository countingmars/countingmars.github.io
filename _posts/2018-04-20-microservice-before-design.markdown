---
layout: post
title:  "마이크로서비스를 설계하기 전에"
date:   2018-04-20 19:25:01
author: Mars
categories: tools
---
 

마이크로서비스를 효과적으로 협업시키기 위해서는 기술적으로 많은 것들을 검토해야 한다.


특정 기술에 종속되어서는 안되며(Technology-Agnostic), 
변경이 호환성을 깨뜨리는(Breaking Change) 기술(예를 들어 필드를 추가했더니 클라이언트에서 오류가 발생한다거나) 또한 피해야 한다.

 
Decoupling을 위해 서비스 사용은 단순해야 하며, 
비동기 방식을 선택하여 서로간의 의존성을 낮추면서도 
비즈니스 로직이 하나의 서비스에 집중되어 핵심 두뇌 역할을 담당하는 것을 방지하는 것이 좋다.     


### Orchestration vs Choreography
복잡한 로직을 모델링하면 각 서비스의 경계를 넘나들어야 하는 경우가 필연적으로 발생한다. 이 경우 어떤 한 서비스가 로직의 중심 두뇌처럼 역할을 할 수도 있고, 비즈니스 지능을 각각의 서비스에게 위임할 수도 있다.

예를 들어 고객을 생성할 때 1. 고객 레코드가 생성되고 2. 가입 환영 패키지를 보내고 3. 가입 환영 이메일을 보낸다고 가정해보자. 


##### 오케스트레이션
오케스트레이션은 지휘자가 모든 프로세스를 안내하고 구동하는 하나의 중앙 두뇌로써 동작한다.
```
class OrchestrationUserService {
	public void createUser(User u) {
		userService.create(u);
		mileageService.createMileageFor(u);
		postOfficeService.sendPackageFor(u);
		welcomeEmailService.sendTo(u);
	}
}
```
오케스트레이션 방식은 핵심 두뇌 서비스에게 지나치게 많은 권한이 부여되게 되고 빈약한 CRUD 서비스를 양산할 수 있다. 
* 일반적인 서비스 설계의 관점에서 보자면, 서비스가 가치있는 역할을 담당해야 존재가치가 있다는 점을 고려하면 빈약한 CRUD 만을 담당하는 서비스라면 다소 아쉬운 설계라고 할 수 있다. 

##### 코레오그래피 
코레오그래피는 고객이 생성되었다는 이벤트만 발생시킬 뿐이다. 나머지 서비스들은 이 이벤트를 구독하고 필요한 시점에 자신의 역할을 수행하게 된다. 이 방식은 비즈니스 프로세스가 암시적으로 반영되어서 이 모든 일이 제대로 수행되었는지 추적하기 어렵다는 단점이 있다. 


이 문제를 해결하기 위해서는 비즈니스 프로세스를 확인할 수 있는 모니터링 시스템을 구축하는 것이다. 


하지만 이 방식의 시스템은 Decoupling이 더 좋아지게 되어 유연하고 변경을 쉽게 수용할 수 있게 된다. 또한 각 서비스가 더 현명하게 자신의 역할을 수행하게 된다.  

```
class ChoreographyUserService {
	public void createUser(User u) {
		userService.create(u);
		eventService.emit('event-user-created', u);
	}
}
```

### 비동기 기술의 선택
비동기 시스템을 가능케해주는 핵심은 메시지 브로커이다. 코레오그래피 시스템 설계의 핵심은 "미들웨어를 멍청하게 엔드포인트를 지능적으로 만들어라"이다. 


하지만 비동기 아키텍처는 복잡하므로 문제를 인지하기 어렵다. 
예를 들어 메시지 브로커의 메시지를 소비하는 클라이언트가 메시지 처리에 실패할 때를 대비하여 Retry 로직을 구현했다고 가정해보자. 
만약 항상 실패할 수 밖에 없는 메시지가 메시지 브로커에 보관되어 있다면 Retry는 항상 실패할 것이다. 
무한히 Retry 하더라도 계속 실패할 것이므로 실패한 메시지는 여러모로 따로 관리하는 것이 좋다.   
   
### 반응형 확장
Reactive Programming은 비동기 시스템과 아주 궁합이 좋고, 성능 또한 월등하다. 


### 다수의 API 비전 관리
만약 API가 V1, V2, V3 이 존재해야 하는 상황이라면, 내부적으로 V1 요청을 V2 요청으로 변환하고, V2 요청을 V3 요청으로 변환해서 처리해보자. 이를 통해 구버전의 엔드 포인트를 중단했을 때 어떤 코드가 제거될 수 있는지 명확하게 이해할 수 있다. 
 

### 트랜잭션의 경계
만약 Monolithic 시스템이라면 거대한 트랜잭션을 구동시켜서 데이터의 일관성을 유지할 수 있을 것이다. 


마이크로서비스 환경에서는 여러 시스템이 하나의 비즈니스 트랜잭션에 관여해야만 한다.
이런 경우에는 최종적 일관성(Eventual Consistency)을 목표로 하는 것이 좋다. 
즉, 실패한 트랜잭션들이 재시도되어 결국에는 성공적으로 완료될 것이라고 가정하는 것이다. 


즉, 트랜잭션의 핵심 데이터가 저장에 성공하면, 나머지는 실패했더라도 나중에 다시 시도하여 해결될 수 있도록 설계하는 것이 좋다. 


 
* 이 글은 샘 뉴먼의 Building Microservices 를 많이 참고한 것입니다.   

 


